package cmanager.gpx;

import cmanager.geo.Geocache;
import cmanager.geo.Waypoint;
import cmanager.global.Constants;
import cmanager.global.Version;
import cmanager.util.FileHelper;
import cmanager.xml.Element;
import cmanager.xml.Parser;
import cmanager.xml.XmlAttribute;
import java.io.InputStream;
import java.io.OutputStream;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class Gpx {

    private static final int CACHES_PER_GPX = 1000;

    public static void loadFromStream(
            InputStream inputStream, final List<Geocache> geocaches, final List<Waypoint> waypoints)
            throws Throwable {
        final ExecutorService service =
                Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() * 2);

        Parser.parse(inputStream, new GpxParserCallback(service, geocaches, waypoints) {});

        service.shutdown();

        // Incredible high delay but still ugly.
        service.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS);
    }

    public static void saveToFile(List<Geocache> list, String listName, String pathToGpx)
            throws Throwable {
        OutputStream outputStream = FileHelper.openFileWrite(pathToGpx);
        ZipOutputStream zipOutputStream = new ZipOutputStream(outputStream);
        zipOutputStream.setLevel(7);

        if (FileHelper.getFileExtension(listName).equals("zip")) {
            listName = listName.substring(0, listName.length() - 4);
        }

        int subListNumber = 0;
        int baseIndex = 0;
        final boolean useSingleFile = list.size() <= CACHES_PER_GPX;
        do {
            final List<Geocache> subList = new ArrayList<>(CACHES_PER_GPX);

            for (int index = 0;
                    index < CACHES_PER_GPX && index + baseIndex < list.size();
                    index++) {
                subList.add(list.get(index + baseIndex));
            }
            baseIndex += CACHES_PER_GPX;
            subListNumber += 1;

            final String subListFileName =
                    useSingleFile ? listName : listName + "-" + subListNumber + ".gpx";
            zipOutputStream.putNextEntry(new ZipEntry(subListFileName));

            final Element root = cacheListToXml(subList, listName);
            Parser.xmlToBuffer(root, zipOutputStream);

            zipOutputStream.closeEntry();
        } while (baseIndex < list.size());

        zipOutputStream.close();
        outputStream.close();
    }

    private static Element cacheListToXml(final List<Geocache> list, String name) {
        final Element root = new Element();

        final Element gpx = new Element("gpx");
        gpx.add(new XmlAttribute("version", "1.0"));
        gpx.add(new XmlAttribute("creator", Constants.APP_NAME));
        gpx.add(
                new XmlAttribute(
                        "xsi:schemaLocation",
                        "http://www.topografix.com/GPX/1/0 http://www.topografix.com/GPX/1/0/gpx.xsd http://www.groundspeak.com/cache/1/0/1 http://www.groundspeak.com/cache/1/0/1/cache.xsd http://www.gsak.net/xmlv1/6 http://www.gsak.net/xmlv1/6/gsak.xsd"));
        gpx.add(new XmlAttribute("xmlns", "http://www.topografix.com/GPX/1/0"));
        gpx.add(new XmlAttribute("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance"));
        gpx.add(new XmlAttribute("xmlns:groundspeak", "http://www.groundspeak.com/cache/1/0/1"));
        gpx.add(new XmlAttribute("xmlns:gsak", "http://www.gsak.net/xmlv1/6"));
        gpx.add(new XmlAttribute("xmlns:cgeo", "http://www.cgeo.org/wptext/1/0"));
        root.add(gpx);

        gpx.add(new Element("name", name));
        gpx.add(
                new Element(
                        "desc",
                        "Geocache file generated by "
                                + Constants.APP_NAME
                                + " "
                                + Version.VERSION));
        gpx.add(new Element("author", Constants.APP_NAME));

        final ZonedDateTime dateTime = ZonedDateTime.now();
        final String dateString = dateTime.format(DateTimeFormatter.ISO_INSTANT);
        gpx.add(new Element("time", dateString));

        for (final Geocache geocache : list) {
            gpx.add(GpxElementUtil.cacheToXml(geocache));
            for (Waypoint waypoint : geocache.getWaypoints()) {
                gpx.add(GpxElementUtil.waypointToXml(waypoint));
            }
        }

        return root;
    }
}
